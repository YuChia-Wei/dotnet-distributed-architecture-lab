> this readme was generated by gemini cli (model: 2.5 pro).

# MQArchLab - 基於 .NET 的現代化訊息驅動架構實踐

MQArchLab 是一個採用 .NET 9、容器化技術和現代軟體架構原則（如 Clean Architecture、DDD、CQRS）建構的範例專案。此專案旨在展示如何設計和開發一個可擴展、具備韌性且易於維護的後端系統。

專案包含兩個核心業務領域：**訂單 (SaleOrders)** 和 **產品 (SaleProducts)**，並透過 RabbitMQ 或 Kafka 進行非同步通訊。

## 架構原則

本專案嚴格遵循以下架構原則：

- **Clean Architecture (CA):** 強制性的關注點分離和依賴規則，確保業務邏輯的獨立性。
- **Domain-Driven Design (DDD):** 專注於核心業務領域和領域邏輯。
- **Command Query Responsibility Segregation (CQRS):** 將讀取和寫入操作分離，以優化效能和可擴展性。

## 核心技術

- **主要框架:** .NET 9
- **主要語言:** C#
- **訊息/命令/查詢處理:** WolverineFx
- **資料庫:** PostgreSQL
- **訊息代理:** RabbitMQ / Kafka
- **容器化:** Docker

## 如何啟動專案

本專案已完全容器化，您只需要在本機安裝 Docker 和 Docker Compose 即可輕鬆啟動。

1.  **選擇訊息代理 (Message Broker)**

    在 `docker-compose/docker-compose.yml` 檔案中，您可以透過設定 `QUEUE_SERVICE` 環境變數來選擇要使用的訊息代理。

    - **使用 Kafka (預設):**
      ```yaml
      # 在 orders-api, orders-consumer, product-api, product-consumer 中
      environment:
        - QUEUE_SERVICE=Kafka
      ```

    - **使用 RabbitMQ:**
      將 `QUEUE_SERVICE` 的值改為 `RabbitMQ`。
      ```yaml
      # 在 orders-api, orders-consumer, product-api, product-consumer 中
      environment:
        - QUEUE_SERVICE=RabbitMQ
      ```

2.  **Clone 專案庫**
    ```bash
    git clone https://github.com/YuChia/dotnet-mq-arch-lab.git
    cd dotnet-mq-arch-lab
    ```

3.  **使用 Docker Compose 啟動所有服務**
    在專案根目錄下，執行以下指令：
    ```bash
    docker-compose -f ./docker-compose/docker-compose.yml up -d
    ```
    此指令將會建置並啟動所有必要的服務，包括：
    - `orders-api`
    - `orders-consumer`
    - `product-api`
    - `product-consumer`
    - `postgres`
    - `rabbitmq` (如果選擇 RabbitMQ)
    - `kafka` (如果選擇 Kafka)
    - `kafka-ui` (如果選擇 Kafka)

## OpenApi with Scalar

專案的 Web API 提供了基於 Scalar 的互動式 API 文件。當專案成功啟動後，您可以透過以下連結存取：

- **訂單服務 (Orders API):**
  - **API 文件:** [http://localhost:8080/scalar/v1](http://localhost:8080/scalar/v1)
  - **OpenAPI Spec:** [http://localhost:8080/openapi/v1](http://localhost:8080/openapi/v1)

- **產品服務 (Products API):**
  - **API 文件:** [http://localhost:8090/scalar/v1](http://localhost:8090/scalar/v1)
  - **OpenAPI Spec:** [http://localhost:8090/openapi/v1](http://localhost:8090/openapi/v1)

## 服務監控

- **Kafka UI:**
  當使用 Kafka 時，您可以透過 [http://localhost:8088](http://localhost:8088) 來存取 Kafka UI。

- **RabbitMQ Management UI:**
  當使用 RabbitMQ 時，您可以透過 [http://localhost:15672](http://localhost:15672) 來監控 RabbitMQ 的佇列和訊息。
  - **帳號:** `guest`
  - **密碼:** `guest`

## 文件目錄

- 設計相關
  - [order / product 中的 command/command handler 做法比較](./docs/program-desighe/command-handler-comparison-of-practices.md)
  - [bc contracts 專案分類](./docs/program-desighe/bc-contracts.md)
- AI 協作紀錄 (AI Agent CLI 的對話輸出紀錄)
  - 功能 002 : order cancel
    - [使用 codex cli 進行實作的紀錄](./docs/SDD-ai-agent-history/feat-002/codex-chat-memo.md)
  - 功能 003 : product consumer order cancelled
    - [使用 gemini cli 執行 spec-kit 命令的紀錄](./docs/SDD-ai-agent-history/feat-003/spec-kit-gemini-cli-gen-history.md)
    - [使用 codex cli 進行實作的紀錄](./docs/SDD-ai-agent-history/feat-003/codex-cli-work-summary.md)

## AI Agents CLI 協作

- AI Agent CLI Default Context
  - Gemini CLI: `agents.md`
    - > 為了方便 gemini 與 codex 共用 default context，有額外於 `.gemini/settings.json` 中設定 `defaultContext`
  - GitHub Copilot: `.github/copilot-instructions.md`
  - Codex: `agents.md`
- AI Agent CLI Extension Commands
  - Gemini CLI：`.gemini/commands/`
  - GitHub Copilot：`.github/prompts/`
  - Codex: `.codex/prompts/`
    - > codex 尚未支援命令參數，且需要利用 `setx CODEX_HOME '{project-floder}\.codex'` 語法來讓 codex 讀取到專案資料夾下的擴充命令
    - > 切換後需要重新登入 codex，且開發完畢需清除環境參數以避免後續工作目錄的錯亂
    - > 因此目前在 codex 中要使用 SDD 的擴充命令時會有諸多限制與需注意的部分

### Spec-Driven Development (規格驅動開發)

- [Spec-Kit](https://github.com/github/spec-kit)

#### agent cli commands

> agent cli 的完整擴充命令清單以及 cli 支援狀況以 spec-kit 官方文件為主

1. Start using slash commands with your AI agent:
    1. /constitution - Establish project principles
    2. /specify - Create specifications
    3. /plan - Create implementation plans
    4. /tasks - Generate actionable tasks
    5. /implement - Execute implementation

#### spec-kit usage

> 使用 `/specify` 命令時，會建立功能規格資料夾以及對應的分支名稱

1. 建立功能分支與規格文件的 PROMPT：
    ```shell
    /specify "功能需求描述"
    ```
2. 建立技術實作的計畫：
    ```shell
    /plan "預期使用什麼樣的做法進行實作，限制使用哪些技術細節"
    ```
3. 建立實作任務清單：
    ```shell
    /tasks
    ```
4. 進行實作：
    ```shell
    /implement
    ```