> this readme was generated by gemini cli (model: 2.5 pro).

# MQArchLab - 基於 .NET 的現代化訊息驅動架構實踐

MQArchLab 是一個採用 .NET 9、容器化技術和現代軟體架構原則（如 Clean Architecture、DDD、CQRS）建構的範例專案。此專案旨在展示如何設計和開發一個可擴展、具備韌性且易於維護的後端系統。

專案包含兩個核心業務領域：**訂單 (SaleOrders)** 和 **產品 (SaleProducts)**，並透過 RabbitMQ 或 Kafka 進行非同步通訊。

## 架構原則

本專案嚴格遵循以下架構原則：

- **Clean Architecture (CA):** 強制性的關注點分離和依賴規則，確保業務邏輯的獨立性。
- **Domain-Driven Design (DDD):** 專注於核心業務領域和領域邏輯。
- **Command Query Responsibility Segregation (CQRS):** 將讀取和寫入操作分離，以優化效能和可擴展性。

## 核心技術

- **主要框架:** .NET 9
- **主要語言:** C#
- **訊息/命令/查詢處理:** WolverineFx
- **資料庫:** PostgreSQL
- **訊息代理:** RabbitMQ / Kafka
- **容器化:** Docker

## 如何啟動專案

本專案已完全容器化，您只需要在本機安裝 Docker 和 Docker Compose 即可輕鬆啟動。

1.  **選擇訊息代理 (Message Broker)**

    在 `docker-compose/docker-compose.yml` 檔案中，您可以透過設定 `QUEUE_SERVICE` 環境變數來選擇要使用的訊息代理。

    - **使用 Kafka (預設):**
      ```yaml
      # 在 orders-api, orders-consumer, product-api, product-consumer 中
      environment:
        - QUEUE_SERVICE=Kafka
      ```

    - **使用 RabbitMQ:**
      將 `QUEUE_SERVICE` 的值改為 `RabbitMQ`。
      ```yaml
      # 在 orders-api, orders-consumer, product-api, product-consumer 中
      environment:
        - QUEUE_SERVICE=RabbitMQ
      ```

2.  **Clone 專案庫**
    ```bash
    git clone https://github.com/YuChia/dotnet-mq-arch-lab.git
    cd dotnet-mq-arch-lab
    ```

3.  **使用 Docker Compose 啟動所有服務**
    在專案根目錄下，執行以下指令：
    ```bash
    docker-compose -f ./docker-compose/docker-compose.yml up -d
    ```
    此指令將會建置並啟動所有必要的服務，包括：
    - `orders-api`
    - `orders-consumer`
    - `product-api`
    - `product-consumer`
    - `postgres`
    - `rabbitmq` (如果選擇 RabbitMQ)
    - `kafka` (如果選擇 Kafka)
    - `kafka-ui` (如果選擇 Kafka)

## API 文件 (Scalar)

專案的 Web API 提供了基於 Scalar 的互動式 API 文件。當專案成功啟動後，您可以透過以下連結存取：

- **訂單服務 (Orders API):**
  - **API 文件:** [http://localhost:8080/scalar/v1](http://localhost:8080/scalar/v1)
  - **OpenAPI Spec:** [http://localhost:8080/openapi/v1](http://localhost:8080/openapi/v1)

- **產品服務 (Products API):**
  - **API 文件:** [http://localhost:8090/scalar/v1](http://localhost:8090/scalar/v1)
  - **OpenAPI Spec:** [http://localhost:8090/openapi/v1](http://localhost:8090/openapi/v1)

## 服務監控

- **Kafka UI:**
  當使用 Kafka 時，您可以透過 [http://localhost:8088](http://localhost:8088) 來存取 Kafka UI。

- **RabbitMQ Management UI:**
  當使用 RabbitMQ 時，您可以透過 [http://localhost:15672](http://localhost:15672) 來監控 RabbitMQ 的佇列和訊息。
  - **帳號:** `guest`
  - **密碼:** `guest`

## 其他設計相關的分析文章

- [order / product 中的 command/command handler 做法比較](./doc/command-handler-comparison-of-practices.md)

## AI Agents 使用與互動

- 規範與流程：請先閱讀 `agents.md`（英文）與 `AGENTS.zh-TW.md`（繁中）。
- 工具鏈位置：
  - Gemini CLI 指令模板：`.gemini/commands/`
  - GitHub Copilot 提示模板：`.github/prompts/`

### 典型工作流程（Spec‑Driven）
- 建立功能與規格：`scripts/create-new-feature.sh "描述"` → 產生分支與 `specs/<branch>/spec.md`
- 產出計畫：`scripts/setup-plan.sh` → `plan.md`；依模板生成 Phase 0/1 產物（`research.md`、`data-model.md`、`contracts/`、`quickstart.md`）
- 規劃任務：`scripts/check-task-prerequisites.sh` 後依模板產生 `tasks.md`
- 同步代理說明：必要時執行 `scripts/update-agent-context.sh [claude|gemini|copilot]`

### 互動原則（重點）
- 變更最小且聚焦；遵循現有結構與命名。
- 大型寫入/結構調整前先更新計畫並標示輸出位置。
- 具風險操作（刪檔、重構、依賴升級、網路/金鑰）需先審批或提供替代方案。
- 測試自變更點開始執行，並補齊必要的 Contract/Integration 測試。

## 貢獻者與 AI 指南

- 主要指南（英文）：`agents.md`
- 正體中文版：`AGENTS.zh-TW.md`
